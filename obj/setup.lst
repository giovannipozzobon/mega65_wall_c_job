###############################################################################
#                                                                             #
# Calypsi ISO C compiler for 6502                               version 5.8.1 #
#                                                       16/Feb/2025  19:09:06 #
# Command line: --target=mega65 --core 45gs02 --no-cross-call -I ./include    #
#               --list-file=obj/setup.lst -o obj/setup.o src/setup.c          #
#                                                                             #
###############################################################################

    \ 0000                      .rtmodel version,"1"
    \ 0000                      .rtmodel codeModel,"plain"
    \ 0000                      .rtmodel core,"45gs02"
    \ 0000                      .rtmodel target,"mega65"
    \ 0000                      .extern _AllocStackSave
    \ 0000                      .extern _RestoreRegisters
    \ 0000                      .extern _Vfp
    \ 0000                      .extern _Vsp
    \ 0000                      .extern _Zp
    \ 0000                      .extern create_sprite
    \ 0000                      .extern debug_msg
    \ 0000                      .extern sprite
0001                #include <calypsi/intrinsics6502.h>
0002                #include "chips.h"
0003                #include "global.h"
0004                #include "setup.h"
0005                #include <sprite.h>
0006
0007                __attribute__((aligned(64))) unsigned int SPRITE_SPACE[360];
0008
0009                extern struct _SPRITE sprite[8];
0010
0011                void initial_setup(void){
    \ 0000                      .section code,text
    \ 0000                      .public initial_setup
    \ 0000          initial_setup:
0012                	__disable_interrupts();
    \ 0000 78                   sei
0013
0014                	// set the speed to 40MHz
0015                	CPU.PORTDDR = 65;
    \ 0001 a941                 lda     #65
    \ 0003 8d0000               sta     0
0016
0017                	// bank out everything except for I/O
0018                	CPU.PORTDDR = 0b00000111;
    \ 0006 a907                 lda     #7
    \ 0008 8d0000               sta     0
0019                	CPU.PORT    = 0b00000101;
    \ 000b a905                 lda     #5
    \ 000d 8d0100               sta     1
0020                	
0021                	// disable CIA interrupts
0022                	/*CIA1.ICR = 0b01111111;
0023                	CIA2.ICR = 0b01111111;
0024
0025                	CIA1.ICR;
0026                	CIA2.ICR;
0027                	*/
0028
0029                	// map I/O (Mega65 memory mapping)
0030                	VIC3.ROM8  = 0;
    \ 0010 a908                 lda     #8
    \ 0012 1c30d0               trb     0xd030
0031                	VIC3.ROMA  = 0;
    \ 0015 a910                 lda     #16
    \ 0017 1c30d0               trb     0xd030
0032                	VIC3.ROMC  = 0;
    \ 001a a920                 lda     #32
    \ 001c 1c30d0               trb     0xd030
0033                	VIC3.CROM9 = 0;
    \ 001f a940                 lda     #64
    \ 0021 1c30d0               trb     0xd030
0034                	VIC3.ROME  = 0;
    \ 0024 a980                 lda     #-128
    \ 0026 1c30d0               trb     0xd030
0035                	
0036                	__asm(" lda #0x00\n"
    \ 0029 a900                 lda     #0
    \ 002b aa                   tax
    \ 002c a8                   tay
    \ 002d 4b                   taz
    \ 002e 5c                   map
    \ 002f ea                   nop
0037                		  " tax\n"
0038                		  " tay\n"
0039                		  " taz\n"
0040                		  " map\n"
0041                		  " nop");
0042                	
0043                	
0044                	// Enable the VIC4
0045                	VIC3.KEY = 0x47;
    \ 0030 a947                 lda     #71
    \ 0032 8d2fd0               sta     0xd02f
0046                	VIC3.KEY = 0x53;
    \ 0035 a953                 lda     #83
    \ 0037 8d2fd0               sta     0xd02f
0047
0048                	// disable RAM protection in banks 2 and 3
0049                	poke(0xD640, 0x70);		// $d640 = HTRAP00
    \ 003a a970                 lda     #112
    \ 003c 8d40d6               sta     0xd640
0050                	__no_operation();		// clv would be better
    \ 003f ea                   nop
0051
0052                	// blank the screen while we do our initial loading
0053                	VIC2.DEN = 0;
    \ 0040 a910                 lda     #16
    \ 0042 1c11d0               trb     0xd011
0054
0055                	// disable raster interrupts
0056                	VIC4.FNRST    = 0;
    \ 0045 a980                 lda     #-128
    \ 0047 1c53d0               trb     0xd053
0057                	VIC4.FNRSTCMP = 0;
    \ 004a a980                 lda     #-128
    \ 004c 1c7ad0               trb     0xd07a
0058                	
0059                	// enable 640 horizontal width
0060                	VIC3.H640 = 1;
    \ 004f ad31d0               lda     0xd031
    \ 0052 0a                   asl     a
    \ 0053 4a                   lsr     a
    \ 0054 0980                 ora     #-128
    \ 0056 8d31d0               sta     0xd031
0061                	
0062                	// disable hot registers
0063                	VIC4.HOTREG = 0;
    \ 0059 a980                 lda     #-128
    \ 005b 1c5dd0               trb     0xd05d
0064
0065
0066                }
    \ 005e 60                   rts
0067
0068
0069                void screen_setup() {
    \ 0000                      .section code,text
    \ 0000                      .public screen_setup
    \ 0000          screen_setup:
0070
0071                	// enable 640 horizontal width
0072                	//VIC3.H640 = 1;
0073                	VIC3.H640 = 0;
    \ 0000 a980                 lda     #-128
    \ 0002 1c31d0               trb     0xd031
0074                	
0075                	// disable hot registers
0076                	//VIC4.HOTREG = 0;
0077                	VIC4.HOTREG = 0;
    \ 0005 a980                 lda     #-128
    \ 0007 1c5dd0               trb     0xd05d
0078                	
0079                	// use wide character lookup (i.e. character data anywhere in memory)
0080                	VIC4.CHR16 = 1;
    \ 000a ad54d0               lda     0xd054
    \ 000d 4a                   lsr     a
    \ 000e 0a                   asl     a
    \ 000f 0901                 ora     #1
    \ 0011 8d54d0               sta     0xd054
0081                	//VIC4.CHR16 = 0;
0082                	
0083                	// set multicolor mode - allows use of both color palettes
0084                	// probably not necessary to turn this on, but it also doesn't hurt.
0085                	VIC2.MCM = 1;
    \ 0014 ad16d0               lda     0xd016
    \ 0017 85..                 sta     zp:_Zp
    \ 0019 47..                 rmb4    zp:_Zp
    \ 001b c7..                 smb4    zp:_Zp
    \ 001d a5..                 lda     zp:_Zp
    \ 001f 8d16d0               sta     0xd016
0086                	
0087
0088                	// set 480 vertical resolution
0089                	set_480();
    \ 0022 20....               jsr     set_480
0090
0091
0092                	VIC4.LINESTEP    = TITLE_LINE_LENGTH;
    \ 0025 a900                 lda     #0
    \ 0027 8d59d0               sta     0xd059
    \ 002a a950                 lda     #80
    \ 002c 8d58d0               sta     0xd058
0093                	VIC4.CHRCOUNTLSB = TITLE_LINE_LENGTH/2;
    \ 002f a928                 lda     #40
    \ 0031 8d5ed0               sta     0xd05e
0094                	VIC4.CHRCOUNTMSB = (TITLE_LINE_LENGTH/2) >> 8;
    \ 0034 a930                 lda     #48
    \ 0036 1c63d0               trb     0xd063
0095                	VIC4.DISPROWS    = TITLE_LINE_COUNT;
    \ 0039 a918                 lda     #24
    \ 003b 8d7bd0               sta     0xd07b
0096
0097                	// use NCM and FCM for all characters
0098                	VIC4.FCLRLO = 0;	// lower block, i.e. 0-255
    \ 003e a902                 lda     #2
    \ 0040 1c54d0               trb     0xd054
0099                	VIC4.FCLRHI = 1;	// everything above 255
    \ 0043 ad54d0               lda     0xd054
    \ 0046 85..                 sta     zp:_Zp
    \ 0048 27..                 rmb2    zp:_Zp
    \ 004a a7..                 smb2    zp:_Zp
    \ 004c a5..                 lda     zp:_Zp
    \ 004e 8d54d0               sta     0xd054
0100
0101                	// set tile map location
0102                	VIC4.SCRNPTR    = SCREEN_MAP & 0xffff;
    \ 0051 a900                 lda     #0
    \ 0053 8d61d0               sta     0xd061
    \ 0056 a900                 lda     #0
    \ 0058 8d60d0               sta     0xd060
0103                	VIC4.SCRNPTRBNK = (SCREEN_MAP & 0xf0000) >> 16;
    \ 005b a905                 lda     #5
    \ 005d 8d62d0               sta     0xd062
0104                	VIC4.SCRNPTRMB  = 0x0;
    \ 0060 a90f                 lda     #15
    \ 0062 1c63d0               trb     0xd063
0105
0106                	// load the attribute map into $ff80000
0107                	
0108                    //run_dma_job((__far char *)&load_title_attrmap);
0109
0110                	// set the border and screen colors to red, to match the picture
0111                	//VIC2.BORDERCOL = 28;
0112                	//VIC2.SCREENCOL = 28;
0113                	VIC2.BORDERCOL = 0;
    \ 0065 a900                 lda     #0
    \ 0067 8d20d0               sta     0xd020
0114                	VIC2.SCREENCOL = 0;
    \ 006a a900                 lda     #0
    \ 006c 8d21d0               sta     0xd021
0115
0116                	// unblank the screen
0117                	VIC2.DEN = 1;
    \ 006f ad11d0               lda     0xd011
    \ 0072 85..                 sta     zp:_Zp
    \ 0074 47..                 rmb4    zp:_Zp
    \ 0076 c7..                 smb4    zp:_Zp
    \ 0078 a5..                 lda     zp:_Zp
    \ 007a 8d11d0               sta     0xd011
0118                		
0119                	// initalize the music
0120                	//musicInit();
0121                }
    \ 007d 60                   rts
0122
0123                /// This procedure sets the top and bottom border positions to allow 480 pixels
0124                /// to be displayed.
0125                void set_480() {
    \ 0000                      .section code,text
    \ 0000                      .public set_480
    \ 0000          set_480:
0126
0127                	// set 480 vertical resolution - this is video standard dependent.
0128                	if (VIC4.PALNTSC) {
    \ 0000 2c6fd0               bit     0xd06f
    \ 0003 1025                 bpl     `?L10`
0129                		VIC4.TBDRPOSLSB  = 0x01;	// defaults to $37/55
    \ 0005 a901                 lda     #1
    \ 0007 8d48d0               sta     0xd048
0130                		VIC4.TBDRPOSMSB  = 0;	    // defaults to $00/0
    \ 000a a90f                 lda     #15
    \ 000c 1c49d0               trb     0xd049
0131                		VIC4.BBDRPOSLSB  = 0xe1;	// defaults to $c7/199
    \ 000f a9e1                 lda     #-31
    \ 0011 8d4ad0               sta     0xd04a
0132                		VIC4.BBDRPOSMSB  = 0x1;	    // defaults to $01/1		(i.e. 455)
    \ 0014 ad4bd0               lda     0xd04b
    \ 0017 29f0                 and     #-16
    \ 0019 0901                 ora     #1
    \ 001b 8d4bd0               sta     0xd04b
0133                		
0134                		VIC4.TEXTYPOSLSB = 0x01;
    \ 001e a901                 lda     #1
    \ 0020 8d4ed0               sta     0xd04e
0135                		VIC4.TEXTYPOSMSB = 0;
    \ 0023 a90f                 lda     #15
    \ 0025 1c4fd0               trb     0xd04f
    \ 0028 8023                 bra     `?L11`
    \ 002a          `?L10`:
0136                	} else {
0137                		VIC4.TBDRPOSLSB  = 0x40;	// defaults to $68/104
    \ 002a a940                 lda     #64
    \ 002c 8d48d0               sta     0xd048
0138                		VIC4.TBDRPOSMSB  = 0;	    // defaults to $00/0
    \ 002f a90f                 lda     #15
    \ 0031 1c49d0               trb     0xd049
0139                		VIC4.BBDRPOSLSB  = 0x20;	// defaults to $f8/248
    \ 0034 a920                 lda     #32
    \ 0036 8d4ad0               sta     0xd04a
0140                		VIC4.BBDRPOSMSB  = 0x2;	    // defaults to $01/1		(i.e. 504)
    \ 0039 ad4bd0               lda     0xd04b
    \ 003c 29f0                 and     #-16
    \ 003e 0902                 ora     #2
    \ 0040 8d4bd0               sta     0xd04b
0141                		
0142                		VIC4.TEXTYPOSLSB = 0x40;
    \ 0043 a940                 lda     #64
    \ 0045 8d4ed0               sta     0xd04e
0143                		VIC4.TEXTYPOSMSB = 0;
    \ 0048 a90f                 lda     #15
    \ 004a 1c4fd0               trb     0xd04f
    \ 004d          `?L11`:
0144                	}
0145                }
    \ 004d 60                   rts
0146
0147                void sprite_setup(void){
    \ 0000                      .section code,text
    \ 0000                      .public sprite_setup
    \ 0000          sprite_setup:
0148                  
0149                	char *sprite_ptr;
0150                	//sprite_ptr = (char *) (SPRITE_RAM);
0151                	sprite_ptr = (char *) (SPRITE_SPACE);
    \ 0000 a9..                 lda     #.byte0 SPRITE_SPACE
    \ 0002 85..                 sta     zp:_Zp
    \ 0004 a9..                 lda     #.byte1 SPRITE_SPACE
    \ 0006 85..                 sta     zp:_Zp+1
0152                	//debug_msg("SPRITE SET");
0153                  
0154                	// set data for 1st sprite
0155                	SPRITE_PTRS[0] = (((int)sprite_ptr) >> 6);
    \ 0008 a5..                 lda     zp:_Zp
    \ 000a 85..                 sta     zp:_Zp+2
    \ 000c a5..                 lda     zp:_Zp+1
    \ 000e 85..                 sta     zp:_Zp+3
    \ 0010 a206                 ldx     #6
    \ 0012 e8                   inx
    \ 0013 ca                   dex
    \ 0014 f009                 beq     `?L45`
    \ 0016 a5..                 lda     zp:_Zp+3
    \ 0018          `?L46`:
    \ 0018 44..                 asr     zp:_Zp+3
    \ 001a 66..                 ror     zp:_Zp+2
    \ 001c ca                   dex
    \ 001d d0f9                 bne     `?L46`
    \ 001f          `?L45`:
    \ 001f a5..                 lda     zp:_Zp+3
    \ 0021 8d....               sta     SPRITE_PTRS+1
    \ 0024 a5..                 lda     zp:_Zp+2
    \ 0026 8d....               sta     SPRITE_PTRS
0156                  
0157                	// set data for 1st sprite
0158                	SPRITE_PTRS[1] = ((((int)sprite_ptr)+24*8) >> 6);
    \ 0029 a5..                 lda     zp:_Zp
    \ 002b 18                   clc
    \ 002c 69c0                 adc     #192
    \ 002e 85..                 sta     zp:_Zp
    \ 0030 a5..                 lda     zp:_Zp+1
    \ 0032 6900                 adc     #0
    \ 0034 85..                 sta     zp:_Zp+1
    \ 0036 a206                 ldx     #6
    \ 0038 e8                   inx
    \ 0039 ca                   dex
    \ 003a f009                 beq     `?L48`
    \ 003c a5..                 lda     zp:_Zp+1
    \ 003e          `?L49`:
    \ 003e 44..                 asr     zp:_Zp+1
    \ 0040 66..                 ror     zp:_Zp
    \ 0042 ca                   dex
    \ 0043 d0f9                 bne     `?L49`
    \ 0045          `?L48`:
    \ 0045 a5..                 lda     zp:_Zp+1
    \ 0047 8d....               sta     SPRITE_PTRS+3
    \ 004a a5..                 lda     zp:_Zp
    \ 004c 8d....               sta     SPRITE_PTRS+2
0159                  
0160                  
0161                	#ifdef DEBUG
0162                	char stringa [10];
0163                	itoa((int)sprite_ptr, stringa+1,10);
0164                	stringa[0]='S';  
0165                	stringa[6]='\0';
0166                	debug_msg(stringa);
0167                  
0168                	itoa(SPRITE_PTRS[0], stringa+1,10);
0169                	stringa[0]='S';  
0170                	stringa[6]='\0';
0171                	debug_msg(stringa);
0172                  
0173                	itoa((unsigned int)SPRITE_PTRS, stringa+1,10);
0174                	stringa[0]='S';  
0175                	stringa[6]='\0';
0176                	debug_msg(stringa);
0177                	#endif
0178                  
0179                	// set location of 16 bit sprite pointers 
0180                	VIC4.SPRPTRADR = (unsigned int)SPRITE_PTRS;
    \ 004f a9..                 lda     #.byte0 SPRITE_PTRS
    \ 0051 8d6cd0               sta     0xd06c
    \ 0054 a9..                 lda     #.byte1 SPRITE_PTRS
    \ 0056 8d6dd0               sta     0xd06d
0181                  
0182                	// enable location of 16 bit sprite pointers bank 
0183                	VIC4.SPRPTR16 = 0x01;
    \ 0059 ad6ed0               lda     0xd06e
    \ 005c 0a                   asl     a
    \ 005d 4a                   lsr     a
    \ 005e 0980                 ora     #-128
    \ 0060 8d6ed0               sta     0xd06e
0184                  
0185                	// full colour sprite mode for sprites (SPR16EN)
0186                	VIC4.SPR16EN = 0x03;
    \ 0063 a903                 lda     #3
    \ 0065 8d6bd0               sta     0xd06b
0187                  
0188                	// 16 pixel wide for sprites (SPRX64EN) 53335
0189                	VIC4.SPRX64EN = 0x03;
    \ 0068 a903                 lda     #3
    \ 006a 8d57d0               sta     0xd057
0190                  
0191                	// 21 pixel high sprite heights
0192                	VIC4.SPRHGHT = 21;
    \ 006d a915                 lda     #21
    \ 006f 8d56d0               sta     0xd056
0193                  
0194                	// all sprites use height in $d056 sprhgten
0195                	VIC4.SPRHGTEN = 0xFF;
    \ 0072 a9ff                 lda     #-1
    \ 0074 8d55d0               sta     0xd055
0196                  
0197                	// sprite multicolor 1
0198                	VIC2.SPRMC0 = 0x08;
    \ 0077 a908                 lda     #8
    \ 0079 8d25d0               sta     0xd025
0199                  
0200                	// sprite multicolor 1
0201                	VIC2.SPRMC1 = 0x06;
    \ 007c a906                 lda     #6
    \ 007e 8d26d0               sta     0xd026
0202                  
0203                	// sprite 0 position X
0204                	VIC2.S0X = 0x20;
    \ 0081 a920                 lda     #32
    \ 0083 8d00d0               sta     0xd000
0205                  
0206                	// sprite 0 position Y
0207                	VIC2.S0Y = 0x20;
    \ 0086 a920                 lda     #32
    \ 0088 8d01d0               sta     0xd001
0208                  
0209                	// sprite 1 position X
0210                	VIC2.S1X = 0x80;
    \ 008b a980                 lda     #-128
    \ 008d 8d02d0               sta     0xd002
0211                  
0212                	// sprite 1 position Y
0213                	VIC2.S1Y = 0x80;
    \ 0090 a980                 lda     #-128
    \ 0092 8d03d0               sta     0xd003
0214                  
0215                	// Sprite enable (SE)
0216                	VIC2.SE = 0x03;
    \ 0095 a903                 lda     #3
    \ 0097 8d15d0               sta     0xd015
0217                  
0218                	// Sprite 0 color 
0219                	VIC2.SPR0COL = 0x00;
    \ 009a a900                 lda     #0
    \ 009c 8d27d0               sta     0xd027
0220                	
0221                	// Sprite 1 color 
0222                	VIC2.SPR1COL = 0x00;
    \ 009f a900                 lda     #0
    \ 00a1 8d28d0               sta     0xd028
0223
0224                	// Sprite 0
0225                	create_sprite(&sprite[0], 0x20, 0x20,0,0b11111110,0b00000001);
    \ 00a4 a901                 lda     #1
    \ 00a6 85..                 sta     zp:_Zp+6
    \ 00a8 a9fe                 lda     #-2
    \ 00aa 85..                 sta     zp:_Zp+5
    \ 00ac a900                 lda     #0
    \ 00ae 85..                 sta     zp:_Zp+4
    \ 00b0 a920                 lda     #32
    \ 00b2 85..                 sta     zp:_Zp+2
    \ 00b4 a900                 lda     #0
    \ 00b6 85..                 sta     zp:_Zp+3
    \ 00b8 a9..                 lda     #.byte0 sprite
    \ 00ba 85..                 sta     zp:_Zp
    \ 00bc a9..                 lda     #.byte1 sprite
    \ 00be 85..                 sta     zp:_Zp+1
    \ 00c0 a920                 lda     #32
    \ 00c2 20....               jsr     create_sprite
0226
0227                	// Sprite 1
0228                	create_sprite(&sprite[1], 0x80, 0x80,1,0b11111101,0b00000010);
    \ 00c5 a902                 lda     #2
    \ 00c7 85..                 sta     zp:_Zp+6
    \ 00c9 a9fd                 lda     #-3
    \ 00cb 85..                 sta     zp:_Zp+5
    \ 00cd a901                 lda     #1
    \ 00cf 85..                 sta     zp:_Zp+4
    \ 00d1 a980                 lda     #128
    \ 00d3 85..                 sta     zp:_Zp+2
    \ 00d5 a900                 lda     #0
    \ 00d7 85..                 sta     zp:_Zp+3
    \ 00d9 a9..                 lda     #.byte0 (sprite+15)
    \ 00db 85..                 sta     zp:_Zp
    \ 00dd a9..                 lda     #.byte1 (sprite+15)
    \ 00df 85..                 sta     zp:_Zp+1
    \ 00e1 a980                 lda     #-128
    \ 00e3 20....               jsr     create_sprite
0229                  
0230                  }
    \ 00e6 60                   rts
0231                  
0232
0233                void setsprite(unsigned char __far  *sprite_begin){
    \ 0000                      .section code,text
    \ 0000                      .public setsprite
    \ 0000          setsprite:
0234
0235                    char *sprite;
0236                    sprite = (char *) (sprite_begin);
    \ 0000 a5..                 lda     zp:_Zp
    \ 0002 85..                 sta     zp:_Zp+4
    \ 0004 a5..                 lda     zp:_Zp+1
    \ 0006 85..                 sta     zp:_Zp+5
0237                  
0238                  
0239                    int len_sprite_definitions = LEN_SPRITE;
    \ 0008 a968                 lda     #104
    \ 000a 85..                 sta     zp:_Zp+4
    \ 000c a901                 lda     #1
    \ 000e 85..                 sta     zp:_Zp+5
0240
0241                	#ifdef DEBUG
0242                	debug_msg("SPRITE");
0243                	char stringa [10];
0244                	itoa(len_sprite_definitions, stringa+1,10);
0245                    stringa[0]='C';  
0246                    stringa[6]='\0';
0247                    debug_msg(stringa);
0248                  	#endif
0249                  
0250                    for (int c = 0; c < len_sprite_definitions; c++) {
    \ 0010 a900                 lda     #0
    \ 0012 85..                 sta     zp:_Zp+6
    \ 0014 a900                 lda     #0
    \ 0016 85..                 sta     zp:_Zp+7
    \ 0018          `?L20`:
    \ 0018 a5..                 lda     zp:_Zp+6
    \ 001a c5..                 cmp     zp:_Zp+4
    \ 001c a5..                 lda     zp:_Zp+7
    \ 001e e5..                 sbc     zp:_Zp+5
    \ 0020 5002                 bvc     `?L53`
    \ 0022 4980                 eor     #-128
    \ 0024 3001     `?L53`:     bmi     `?L19`
0251                        //FAR_U8_PTR(SPRITE_RAM) [c] = sprite_begin[c]; 
0252                        FAR_U8_PTR(SPRITE_SPACE) [c] = sprite_begin[c]; 
0253                        //debug_char(charset[c]);
0254                    }
0255
0256                };
    \ 0026 60                   rts
    \ 0027          `?L19`:
    \ 0027 4242a5..             ldq     zp:_Zp
    \ 002b 424285..             stq     zp:_Zp+8
    \ 002f 18                   clc
    \ 0030 a5..                 lda     zp:_Zp+8
    \ 0032 65..                 adc     zp:_Zp+6
    \ 0034 85..                 sta     zp:_Zp+8
    \ 0036 a5..                 lda     zp:_Zp+9
    \ 0038 65..                 adc     zp:_Zp+7
    \ 003a 85..                 sta     zp:_Zp+9
    \ 003c a300                 ldz     #0
    \ 003e eab2..               lda     [_Zp+8],z
    \ 0041 48                   pha
    \ 0042 a2..                 ldx     #.byte0 SPRITE_SPACE
    \ 0044 86..                 stx     zp:_Zp+8
    \ 0046 a2..                 ldx     #.byte1 SPRITE_SPACE
    \ 0048 86..                 stx     zp:_Zp+9
    \ 004a a200                 ldx     #0
    \ 004c 86..                 stx     zp:_Zp+10
    \ 004e 86..                 stx     zp:_Zp+11
    \ 0050 18                   clc
    \ 0051 a5..                 lda     zp:_Zp+8
    \ 0053 65..                 adc     zp:_Zp+6
    \ 0055 85..                 sta     zp:_Zp+8
    \ 0057 a5..                 lda     zp:_Zp+9
    \ 0059 65..                 adc     zp:_Zp+7
    \ 005b 85..                 sta     zp:_Zp+9
    \ 005d 68                   pla
    \ 005e a300                 ldz     #0
    \ 0060 ea92..               sta     [_Zp+8],z
    \ 0063 e3..                 inw     zp:_Zp+6
    \ 0065 80b1                 bra     `?L20`
0257
0258
0259                void setchar(unsigned char __far  *charset_begin){
    \ 0000                      .section code,text
    \ 0000                      .public setchar
    \ 0000          setchar:
0260
0261                    unsigned char __far *charset;
0262                    charset = charset_begin;
0263                    //charset =  (attic_memory_charset);
0264
0265                	int num_char_definitions = (LEN_CHARSET);
    \ 0000 a900                 lda     #0
    \ 0002 85..                 sta     zp:_Zp+4
    \ 0004 a940                 lda     #64
    \ 0006 85..                 sta     zp:_Zp+5
0266                	
0267                	#ifdef DEBUG
0268                	char stringa [10];
0269                    debug_msg("CHARSET SET");
0270                  
0271                    itoa(num_char_definitions, stringa+1,10);
0272                    stringa[0]='C';  
0273                    stringa[6]='\0';
0274                    debug_msg(stringa);
0275                	#endif
0276                  
0277                  
0278                    for (int c = 0; c < num_char_definitions; c++) {
    \ 0008 a900                 lda     #0
    \ 000a 85..                 sta     zp:_Zp+6
    \ 000c a900                 lda     #0
    \ 000e 85..                 sta     zp:_Zp+7
    \ 0010          `?L27`:
    \ 0010 a5..                 lda     zp:_Zp+6
    \ 0012 c5..                 cmp     zp:_Zp+4
    \ 0014 a5..                 lda     zp:_Zp+7
    \ 0016 e5..                 sbc     zp:_Zp+5
    \ 0018 5002                 bvc     `?L55`
    \ 001a 4980                 eor     #-128
    \ 001c 3001     `?L55`:     bmi     `?L26`
0279                        FAR_U8_PTR(CHARSET_MEMORY) [c] = charset[c];
0280                    }
0281
0282                };
    \ 001e 60                   rts
    \ 001f          `?L26`:
    \ 001f 4242a5..             ldq     zp:_Zp
    \ 0023 424285..             stq     zp:_Zp+8
    \ 0027 18                   clc
    \ 0028 a5..                 lda     zp:_Zp+8
    \ 002a 65..                 adc     zp:_Zp+6
    \ 002c 85..                 sta     zp:_Zp+8
    \ 002e a5..                 lda     zp:_Zp+9
    \ 0030 65..                 adc     zp:_Zp+7
    \ 0032 85..                 sta     zp:_Zp+9
    \ 0034 a300                 ldz     #0
    \ 0036 eab2..               lda     [_Zp+8],z
    \ 0039 48                   pha
    \ 003a a900                 lda     #0
    \ 003c a240                 ldx     #64
    \ 003e a004                 ldy     #4
    \ 0040 a300                 ldz     #0
    \ 0042 424285..             stq     zp:_Zp+8
    \ 0046 18                   clc
    \ 0047 a5..                 lda     zp:_Zp+8
    \ 0049 65..                 adc     zp:_Zp+6
    \ 004b 85..                 sta     zp:_Zp+8
    \ 004d a5..                 lda     zp:_Zp+9
    \ 004f 65..                 adc     zp:_Zp+7
    \ 0051 85..                 sta     zp:_Zp+9
    \ 0053 68                   pla
    \ 0054 a300                 ldz     #0
    \ 0056 ea92..               sta     [_Zp+8],z
    \ 0059 e3..                 inw     zp:_Zp+6
    \ 005b 80b3                 bra     `?L27`
0283
0284                void setscreen(unsigned char __far  *screen_begin){
    \ 0000                      .section code,text
    \ 0000                      .public setscreen
    \ 0000 a200     setscreen:  ldx     #0
    \ 0002 a003                 ldy     #3
    \ 0004 20....               jsr     _AllocStackSave
0285                    char stringa [10];
0286                    unsigned char __far *screen;
0287                    screen = screen_begin;
    \ 0007 4242a5..             ldq     zp:_Zp
    \ 000b 424285..             stq     zp:_Zp+24
0288                    debug_msg("SCREEN SET");
    \ 000f a9..                 lda     #.byte0 `_StringLiteral_SCREEN SET`
    \ 0011 85..                 sta     zp:_Zp
    \ 0013 a9..                 lda     #.byte1 `_StringLiteral_SCREEN SET`
    \ 0015 85..                 sta     zp:_Zp+1
    \ 0017 20....               jsr     debug_msg
0289                  
0290                    // copy special characters
0291                    int num_char_screen = (LEN_SCREEN);
    \ 001a a9d0                 lda     #208
    \ 001c 85..                 sta     zp:_Zp
    \ 001e a907                 lda     #7
    \ 0020 85..                 sta     zp:_Zp+1
0292                    
0293                	#ifdef DEBUG
0294                	char stringa [10];
0295
0296                	itoa(num_char_screen, stringa+1,10);
0297                	stringa[0]='S';  
0298                	stringa[6]='\0';
0299                	debug_msg(stringa);
0300
0301                	itoa(num_char_screen, stringa+1,10);
0302                    stringa[0]='S';  
0303                    stringa[6]='\0';
0304                    debug_msg(stringa);
0305                  
0306                    itoa(((CHARSET_MEMORY / 64) >> 8),stringa+1,10);
0307                    stringa[0]='T';  
0308                    stringa[6]='\0';
0309                    debug_msg(stringa);
0310                	#endif
0311                  
0312                    
0313                    for (int c = 0; c < num_char_screen; c=c+2) {
    \ 0022 a900                 lda     #0
    \ 0024 85..                 sta     zp:_Zp+2
    \ 0026 a900                 lda     #0
    \ 0028 85..                 sta     zp:_Zp+3
    \ 002a          `?L34`:
    \ 002a a5..                 lda     zp:_Zp+2
    \ 002c c5..                 cmp     zp:_Zp
    \ 002e a5..                 lda     zp:_Zp+3
    \ 0030 e5..                 sbc     zp:_Zp+1
    \ 0032 5002                 bvc     `?L59`
    \ 0034 4980                 eor     #-128
    \ 0036 3005     `?L59`:     bmi     `?L33`
0314                        FAR_U8_PTR(SCREEN_MAP) [c] = screen[c];
0315                        FAR_U8_PTR(SCREEN_MAP) [c+1] = ((CHARSET_MEMORY / 64) >> 8);
0316                        //debug_char(screen[c]);
0317                    }
0318                };
    \ 0038 a003                 ldy     #3
    \ 003a 4c....               jmp     _RestoreRegisters
    \ 003d          `?L33`:
    \ 003d 4242a5..             ldq     zp:_Zp+24
    \ 0041 424285..             stq     zp:_Zp+4
    \ 0045 18                   clc
    \ 0046 a5..                 lda     zp:_Zp+4
    \ 0048 65..                 adc     zp:_Zp+2
    \ 004a 85..                 sta     zp:_Zp+4
    \ 004c a5..                 lda     zp:_Zp+5
    \ 004e 65..                 adc     zp:_Zp+3
    \ 0050 85..                 sta     zp:_Zp+5
    \ 0052 a300                 ldz     #0
    \ 0054 eab2..               lda     [_Zp+4],z
    \ 0057 48                   pha
    \ 0058 a900                 lda     #0
    \ 005a a200                 ldx     #0
    \ 005c a005                 ldy     #5
    \ 005e a300                 ldz     #0
    \ 0060 424285..             stq     zp:_Zp+4
    \ 0064 18                   clc
    \ 0065 a5..                 lda     zp:_Zp+4
    \ 0067 65..                 adc     zp:_Zp+2
    \ 0069 85..                 sta     zp:_Zp+4
    \ 006b a5..                 lda     zp:_Zp+5
    \ 006d 65..                 adc     zp:_Zp+3
    \ 006f 85..                 sta     zp:_Zp+5
    \ 0071 68                   pla
    \ 0072 a300                 ldz     #0
    \ 0074 ea92..               sta     [_Zp+4],z
    \ 0077 a900                 lda     #0
    \ 0079 a200                 ldx     #0
    \ 007b a005                 ldy     #5
    \ 007d a300                 ldz     #0
    \ 007f 424285..             stq     zp:_Zp+4
    \ 0083 a5..                 lda     zp:_Zp+2
    \ 0085 85..                 sta     zp:_Zp+8
    \ 0087 a5..                 lda     zp:_Zp+3
    \ 0089 85..                 sta     zp:_Zp+9
    \ 008b e3..                 inw     zp:_Zp+8
    \ 008d 18                   clc
    \ 008e a5..                 lda     zp:_Zp+4
    \ 0090 65..                 adc     zp:_Zp+8
    \ 0092 85..                 sta     zp:_Zp+4
    \ 0094 a5..                 lda     zp:_Zp+5
    \ 0096 65..                 adc     zp:_Zp+9
    \ 0098 85..                 sta     zp:_Zp+5
    \ 009a a911                 lda     #17
    \ 009c a300                 ldz     #0
    \ 009e ea92..               sta     [_Zp+4],z
    \ 00a1 e3..                 inw     zp:_Zp+2
    \ 00a3 e3..                 inw     zp:_Zp+2
    \ 00a5 8083                 bra     `?L34`
0319
0320                void colorset_init(void)
0321                {
    \ 0000                      .section code,text
    \ 0000                      .public colorset_init
    \ 0000          colorset_init:
0322
0323                  //char *color;
0324                  //color = (char *) &charcolor_begin;
0325
0326
0327                  // copy special characters
0328                  int num_color = 2000;
    \ 0000 a9d0                 lda     #208
    \ 0002 85..                 sta     zp:_Zp
    \ 0004 a907                 lda     #7
    \ 0006 85..                 sta     zp:_Zp+1
0329
0330                  #ifdef DEBUG
0331                  char stringa [10];
0332                  debug_msg("COLOR SET");
0333                  itoa(num_color, stringa+1,10);
0334                  stringa[0]='O';  
0335                  stringa[6]='\0';
0336                  debug_msg(stringa);
0337                  #endif
0338
0339                  // il primo byte è zero e il secondo contiene un colore
0340                  // non so se venga utilizzato perché sembra sempre uguale
0341                  // da verificare come funziona perché non ho capito
0342                  for (int c = 0; c < num_color; c=c+2) {
    \ 0008 a900                 lda     #0
    \ 000a 85..                 sta     zp:_Zp+2
    \ 000c a900                 lda     #0
    \ 000e 85..                 sta     zp:_Zp+3
    \ 0010          `?L41`:
    \ 0010 a5..                 lda     zp:_Zp+2
    \ 0012 c5..                 cmp     zp:_Zp
    \ 0014 a5..                 lda     zp:_Zp+3
    \ 0016 e5..                 sbc     zp:_Zp+1
    \ 0018 5002                 bvc     `?L61`
    \ 001a 4980                 eor     #-128
    \ 001c 3001     `?L61`:     bmi     `?L40`
0343                    FAR_U8_PTR(0xff80000) [c] = 0;
0344                    FAR_U8_PTR(0xff80000) [c+1] = 10;
0345                  }
0346                }
    \ 001e 60                   rts
    \ 001f a900     `?L40`:     lda     #0
    \ 0021 a200                 ldx     #0
    \ 0023 a0f8                 ldy     #248
    \ 0025 a30f                 ldz     #15
    \ 0027 424285..             stq     zp:_Zp+4
    \ 002b 18                   clc
    \ 002c a5..                 lda     zp:_Zp+4
    \ 002e 65..                 adc     zp:_Zp+2
    \ 0030 85..                 sta     zp:_Zp+4
    \ 0032 a5..                 lda     zp:_Zp+5
    \ 0034 65..                 adc     zp:_Zp+3
    \ 0036 85..                 sta     zp:_Zp+5
    \ 0038 a900                 lda     #0
    \ 003a a300                 ldz     #0
    \ 003c ea92..               sta     [_Zp+4],z
    \ 003f a900                 lda     #0
    \ 0041 a200                 ldx     #0
    \ 0043 a0f8                 ldy     #248
    \ 0045 a30f                 ldz     #15
    \ 0047 424285..             stq     zp:_Zp+4
    \ 004b a5..                 lda     zp:_Zp+2
    \ 004d 85..                 sta     zp:_Zp+8
    \ 004f a5..                 lda     zp:_Zp+3
    \ 0051 85..                 sta     zp:_Zp+9
    \ 0053 e3..                 inw     zp:_Zp+8
    \ 0055 18                   clc
    \ 0056 a5..                 lda     zp:_Zp+4
    \ 0058 65..                 adc     zp:_Zp+8
    \ 005a 85..                 sta     zp:_Zp+4
    \ 005c a5..                 lda     zp:_Zp+5
    \ 005e 65..                 adc     zp:_Zp+9
    \ 0060 85..                 sta     zp:_Zp+5
    \ 0062 a90a                 lda     #10
    \ 0064 a300                 ldz     #0
    \ 0066 ea92..               sta     [_Zp+4],z
    \ 0069 e3..                 inw     zp:_Zp+2
    \ 006b e3..                 inw     zp:_Zp+2
    \ 006d 80a1                 bra     `?L41`
    \ 0000                      .section data,data
    \ 0000                      .public attic_memory_charset
    \ 0000          attic_memory_charset:
    \ 0000 00450108             .long   0x8014500
    \ 0000                      .section data,data
    \ 0000                      .public attic_memory_sprite
    \ 0000          attic_memory_sprite:
    \ 0000 00450208             .long   0x8024500
    \ 0000                      .section data,data
    \ 0000                      .public attic_memory_screen
    \ 0000          attic_memory_screen:
    \ 0000 00450308             .long   0x8034500
    \ 0000                      .section data,data
    \ 0000                      .public attic_memory_attr
    \ 0000          attic_memory_attr:
    \ 0000 00450408             .long   0x8044500
    \ 0000                      .section data,data
    \ 0000                      .public charfile
    \ 0000 43484152 charfile:   .byte   67,72,65,82,83,0
    \ 0004 5300
    \ 0000                      .section data,data
    \ 0000                      .public screenfile
    \ 0000 53435245 screenfile: .byte   83,67,82,69,69,78,0
    \ 0004 454e00
    \ 0000                      .section data,data
    \ 0000                      .public spritefile
    \ 0000 53505249 spritefile: .byte   83,80,82,73,84,69,0
    \ 0004 544500
    \ 0000                      .section zdata,bss
    \ 0000                      .public SPRITE_PTRS
    \ 0000                      .align  16
    \ 0000          SPRITE_PTRS:
    \ 0000                      .space  16
    \ 0000                      .section zdata,bss
    \ 0000                      .public SPRITE_SPACE
    \ 0000                      .align  64
    \ 0000          SPRITE_SPACE:
    \ 0000                      .space  0x2d0
    \ 0000                      .section cdata,rodata
    \ 0000                      .pubweak `_StringLiteral_SCREEN SET`
    \ 0000          `_StringLiteral_SCREEN SET`:
    \ 0000 53435245             .byte   83,67,82,69,69,78,32,83,69,84,0
    \ 0004 454e2053
    \ 0008 455400

##########################
#                        #
# Memory sizes (decimal) #
#                        #
##########################

Executable        (Text): 1004 bytes
Zero initialized   (BSS):  736 bytes
Data                    :   36 bytes
Constant                :   11 bytes
